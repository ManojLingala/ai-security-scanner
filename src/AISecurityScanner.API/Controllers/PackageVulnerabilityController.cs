using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Authorization;
using AISecurityScanner.Application.Interfaces;
using AISecurityScanner.Application.DTOs;
using AISecurityScanner.Application.Models;

namespace AISecurityScanner.API.Controllers
{
    [Authorize]
    public class PackageVulnerabilityController : BaseController
    {
        private readonly IPackageVulnerabilityService _packageVulnerabilityService;
        private readonly ISecurityScannerService _scannerService;
        private readonly ILogger<PackageVulnerabilityController> _logger;

        public PackageVulnerabilityController(
            IPackageVulnerabilityService packageVulnerabilityService,
            ISecurityScannerService scannerService,
            ILogger<PackageVulnerabilityController> logger)
        {
            _packageVulnerabilityService = packageVulnerabilityService;
            _scannerService = scannerService;
            _logger = logger;
        }

        /// <summary>
        /// Get package vulnerability summary for a specific scan
        /// </summary>
        [HttpGet("scan/{scanId}/summary")]
        public async Task<ActionResult<PackageScanSummary>> GetPackageScanSummary(
            Guid scanId,
            CancellationToken cancellationToken)
        {
            try
            {
                var summary = await _scannerService.GetPackageVulnerabilitiesAsync(scanId, cancellationToken);
                return Ok(summary);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error getting package scan summary for scan {ScanId}", scanId);
                return BadRequest(new { message = "Failed to retrieve package scan summary" });
            }
        }

        /// <summary>
        /// Get detailed package vulnerabilities for a specific scan
        /// </summary>
        [HttpGet("scan/{scanId}")]
        public async Task<ActionResult<List<PackageVulnerabilityDto>>> GetPackageVulnerabilities(
            Guid scanId,
            CancellationToken cancellationToken)
        {
            try
            {
                var vulnerabilities = await _packageVulnerabilityService.GetVulnerabilitiesForScanAsync(scanId, cancellationToken);
                return Ok(vulnerabilities);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error getting package vulnerabilities for scan {ScanId}", scanId);
                return BadRequest(new { message = "Failed to retrieve package vulnerabilities" });
            }
        }

        /// <summary>
        /// Scan NuGet packages in a project file
        /// </summary>
        [HttpPost("scan/nuget")]
        public async Task<ActionResult<List<PackageVulnerabilityDto>>> ScanNuGetPackages(
            [FromBody] NuGetScanRequest request,
            CancellationToken cancellationToken)
        {
            try
            {
                if (string.IsNullOrEmpty(request.ProjectFilePath))
                {
                    return BadRequest(new { message = "Project file path is required" });
                }

                var vulnerabilities = await _packageVulnerabilityService.ScanNuGetPackagesAsync(
                    request.ProjectFilePath, 
                    request.ScanId, 
                    cancellationToken);

                return Ok(vulnerabilities);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error scanning NuGet packages for {File}", request.ProjectFilePath);
                return BadRequest(new { message = "Failed to scan NuGet packages" });
            }
        }

        /// <summary>
        /// Scan npm packages in a package.json file
        /// </summary>
        [HttpPost("scan/npm")]
        public async Task<ActionResult<List<PackageVulnerabilityDto>>> ScanNpmPackages(
            [FromBody] NpmScanRequest request,
            CancellationToken cancellationToken)
        {
            try
            {
                if (string.IsNullOrEmpty(request.PackageJsonPath))
                {
                    return BadRequest(new { message = "package.json path is required" });
                }

                var vulnerabilities = await _packageVulnerabilityService.ScanNpmPackagesAsync(
                    request.PackageJsonPath, 
                    request.ScanId, 
                    cancellationToken);

                return Ok(vulnerabilities);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error scanning npm packages for {File}", request.PackageJsonPath);
                return BadRequest(new { message = "Failed to scan npm packages" });
            }
        }

        /// <summary>
        /// Check if a specific package exists in its registry
        /// </summary>
        [HttpPost("check-existence")]
        public async Task<ActionResult<PackageExistenceResult>> CheckPackageExistence(
            [FromBody] PackageExistenceRequest request,
            CancellationToken cancellationToken)
        {
            try
            {
                if (string.IsNullOrEmpty(request.PackageName) || string.IsNullOrEmpty(request.PackageManager))
                {
                    return BadRequest(new { message = "Package name and package manager are required" });
                }

                var exists = await _packageVulnerabilityService.CheckPackageExistsAsync(
                    request.PackageName, 
                    request.PackageManager, 
                    cancellationToken);

                return Ok(new PackageExistenceResult
                {
                    PackageName = request.PackageName,
                    PackageManager = request.PackageManager,
                    Exists = exists,
                    CheckedAt = DateTime.UtcNow
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error checking package existence for {Package} ({Manager})", 
                    request.PackageName, request.PackageManager);
                return BadRequest(new { message = "Failed to check package existence" });
            }
        }

        /// <summary>
        /// Get AI hallucination analysis for packages in a scan
        /// </summary>
        [HttpGet("scan/{scanId}/hallucination-analysis")]
        public async Task<ActionResult<HallucinationAnalysisResult>> GetHallucinationAnalysis(
            Guid scanId,
            CancellationToken cancellationToken)
        {
            try
            {
                var vulnerabilities = await _packageVulnerabilityService.GetVulnerabilitiesForScanAsync(scanId, cancellationToken);
                var hallucinatedPackages = vulnerabilities.Where(v => v.IsPotentiallyHallucinated).ToList();

                var analysis = new HallucinationAnalysisResult
                {
                    ScanId = scanId,
                    TotalPackagesScanned = vulnerabilities.Count,
                    HallucinatedPackagesCount = hallucinatedPackages.Count,
                    HallucinationRate = vulnerabilities.Count > 0 
                        ? (decimal)hallucinatedPackages.Count / vulnerabilities.Count * 100 
                        : 0,
                    HighConfidenceHallucinations = hallucinatedPackages
                        .Where(v => v.HallucinationConfidence > 0.8m)
                        .Count(),
                    HallucinatedPackages = hallucinatedPackages.Select(v => new HallucinatedPackageInfo
                    {
                        PackageName = v.PackageName,
                        PackageManager = v.PackageManager,
                        Version = v.Version,
                        Confidence = v.HallucinationConfidence,
                        Reason = v.HallucinationReason ?? "",
                        FilePath = v.FilePath ?? ""
                    }).ToList(),
                    AnalyzedAt = DateTime.UtcNow
                };

                return Ok(analysis);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error getting hallucination analysis for scan {ScanId}", scanId);
                return BadRequest(new { message = "Failed to retrieve hallucination analysis" });
            }
        }

        /// <summary>
        /// Get vulnerability statistics by package manager
        /// </summary>
        [HttpGet("scan/{scanId}/statistics")]
        public async Task<ActionResult<PackageVulnerabilityStatistics>> GetVulnerabilityStatistics(
            Guid scanId,
            CancellationToken cancellationToken)
        {
            try
            {
                var vulnerabilities = await _packageVulnerabilityService.GetVulnerabilitiesForScanAsync(scanId, cancellationToken);

                var statistics = new PackageVulnerabilityStatistics
                {
                    ScanId = scanId,
                    TotalPackages = vulnerabilities.Count,
                    
                    StatsByPackageManager = vulnerabilities
                        .GroupBy(v => v.PackageManager)
                        .ToDictionary(g => g.Key, g => new PackageManagerStats
                        {
                            TotalPackages = g.Count(),
                            VulnerablePackages = g.Count(v => v.HasKnownVulnerabilities),
                            OutdatedPackages = g.Count(v => v.IsOutdated),
                            HallucinatedPackages = g.Count(v => v.IsPotentiallyHallucinated),
                            CriticalVulnerabilities = g.Count(v => v.Severity == Domain.Enums.VulnerabilitySeverity.Critical),
                            HighVulnerabilities = g.Count(v => v.Severity == Domain.Enums.VulnerabilitySeverity.High)
                        }),
                    
                    TopVulnerablePackages = vulnerabilities
                        .Where(v => v.HasKnownVulnerabilities || v.IsPotentiallyHallucinated)
                        .OrderByDescending(v => v.Severity)
                        .ThenByDescending(v => v.HallucinationConfidence)
                        .Take(10)
                        .Select(v => new VulnerablePackageInfo
                        {
                            PackageName = v.PackageName,
                            Version = v.Version,
                            PackageManager = v.PackageManager,
                            Severity = v.Severity,
                            IsHallucinated = v.IsPotentiallyHallucinated,
                            HallucinationConfidence = v.HallucinationConfidence
                        })
                        .ToList(),
                    
                    GeneratedAt = DateTime.UtcNow
                };

                return Ok(statistics);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error getting vulnerability statistics for scan {ScanId}", scanId);
                return BadRequest(new { message = "Failed to retrieve vulnerability statistics" });
            }
        }
    }

    // Request/Response models
    public class NuGetScanRequest
    {
        public string ProjectFilePath { get; set; } = "";
        public Guid ScanId { get; set; }
    }

    public class NpmScanRequest
    {
        public string PackageJsonPath { get; set; } = "";
        public Guid ScanId { get; set; }
    }

    public class PackageExistenceRequest
    {
        public string PackageName { get; set; } = "";
        public string PackageManager { get; set; } = "";
    }

    public class PackageExistenceResult
    {
        public string PackageName { get; set; } = "";
        public string PackageManager { get; set; } = "";
        public bool Exists { get; set; }
        public DateTime CheckedAt { get; set; }
    }

    public class HallucinationAnalysisResult
    {
        public Guid ScanId { get; set; }
        public int TotalPackagesScanned { get; set; }
        public int HallucinatedPackagesCount { get; set; }
        public decimal HallucinationRate { get; set; }
        public int HighConfidenceHallucinations { get; set; }
        public List<HallucinatedPackageInfo> HallucinatedPackages { get; set; } = new();
        public DateTime AnalyzedAt { get; set; }
    }

    public class HallucinatedPackageInfo
    {
        public string PackageName { get; set; } = "";
        public string PackageManager { get; set; } = "";
        public string Version { get; set; } = "";
        public decimal Confidence { get; set; }
        public string Reason { get; set; } = "";
        public string FilePath { get; set; } = "";
    }

    public class PackageVulnerabilityStatistics
    {
        public Guid ScanId { get; set; }
        public int TotalPackages { get; set; }
        public Dictionary<string, PackageManagerStats> StatsByPackageManager { get; set; } = new();
        public List<VulnerablePackageInfo> TopVulnerablePackages { get; set; } = new();
        public DateTime GeneratedAt { get; set; }
    }

    public class PackageManagerStats
    {
        public int TotalPackages { get; set; }
        public int VulnerablePackages { get; set; }
        public int OutdatedPackages { get; set; }
        public int HallucinatedPackages { get; set; }
        public int CriticalVulnerabilities { get; set; }
        public int HighVulnerabilities { get; set; }
    }

    public class VulnerablePackageInfo
    {
        public string PackageName { get; set; } = "";
        public string Version { get; set; } = "";
        public string PackageManager { get; set; } = "";
        public Domain.Enums.VulnerabilitySeverity Severity { get; set; }
        public bool IsHallucinated { get; set; }
        public decimal HallucinationConfidence { get; set; }
    }
}