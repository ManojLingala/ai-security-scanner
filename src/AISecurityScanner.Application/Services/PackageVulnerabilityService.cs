using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Threading;
using System.Threading.Tasks;
using AISecurityScanner.Application.Interfaces;
using AISecurityScanner.Domain.Entities;
using AISecurityScanner.Domain.Interfaces;
using Microsoft.Extensions.Logging;

namespace AISecurityScanner.Application.Services
{
    public class PackageVulnerabilityService : IPackageVulnerabilityService
    {
        private readonly IUnitOfWork _unitOfWork;
        private readonly INuGetPackageScanner _nugetScanner;
        private readonly INpmPackageScanner _npmScanner;
        private readonly IHallucinationDetectionService _hallucinationService;
        private readonly ILogger<PackageVulnerabilityService> _logger;

        public PackageVulnerabilityService(
            IUnitOfWork unitOfWork,
            INuGetPackageScanner nugetScanner,
            INpmPackageScanner npmScanner,
            IHallucinationDetectionService hallucinationService,
            ILogger<PackageVulnerabilityService> logger)
        {
            _unitOfWork = unitOfWork;
            _nugetScanner = nugetScanner;
            _npmScanner = npmScanner;
            _hallucinationService = hallucinationService;
            _logger = logger;
        }

        public async Task<List<PackageVulnerability>> ScanNuGetPackagesAsync(
            string projectFilePath, 
            Guid scanId,
            CancellationToken cancellationToken = default)
        {
            try
            {
                _logger.LogInformation("Starting NuGet package scan for {File}", projectFilePath);
                
                var vulnerabilities = await _nugetScanner.ScanProjectAsync(
                    projectFilePath, scanId, cancellationToken);

                // Check each vulnerability for hallucination
                foreach (var vulnerability in vulnerabilities)
                {
                    await CheckForHallucinationAsync(vulnerability, cancellationToken);
                    
                    // Save to database
                    await _unitOfWork.GetRepository<PackageVulnerability>()
                        .AddAsync(vulnerability, cancellationToken);
                }

                await _unitOfWork.SaveChangesAsync(cancellationToken);
                
                _logger.LogInformation("Found {Count} NuGet vulnerabilities in {File}", 
                    vulnerabilities.Count, projectFilePath);
                
                return vulnerabilities;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error scanning NuGet packages in {File}", projectFilePath);
                throw;
            }
        }

        public async Task<List<PackageVulnerability>> ScanNpmPackagesAsync(
            string packageJsonPath, 
            Guid scanId,
            CancellationToken cancellationToken = default)
        {
            try
            {
                _logger.LogInformation("Starting npm package scan for {File}", packageJsonPath);
                
                var vulnerabilities = await _npmScanner.ScanPackageJsonAsync(
                    packageJsonPath, scanId, cancellationToken);

                // Check each vulnerability for hallucination
                foreach (var vulnerability in vulnerabilities)
                {
                    await CheckForHallucinationAsync(vulnerability, cancellationToken);
                    
                    // Save to database
                    await _unitOfWork.GetRepository<PackageVulnerability>()
                        .AddAsync(vulnerability, cancellationToken);
                }

                await _unitOfWork.SaveChangesAsync(cancellationToken);
                
                _logger.LogInformation("Found {Count} npm vulnerabilities in {File}", 
                    vulnerabilities.Count, packageJsonPath);
                
                return vulnerabilities;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error scanning npm packages in {File}", packageJsonPath);
                throw;
            }
        }

        public async Task<List<PackageVulnerability>> ScanPythonPackagesAsync(
            string requirementsPath, 
            Guid scanId,
            CancellationToken cancellationToken = default)
        {
            // Python implementation would go here
            // For now, return empty list
            _logger.LogInformation("Python package scanning not yet implemented");
            return await Task.FromResult(new List<PackageVulnerability>());
        }

        public async Task<bool> CheckPackageExistsAsync(
            string packageName, 
            string packageManager,
            CancellationToken cancellationToken = default)
        {
            var result = await _hallucinationService.CheckForHallucinationAsync(
                packageName, packageManager, null, cancellationToken);
            
            return result.ExistsInRegistry;
        }

        public async Task<PackageVulnerability> CheckForHallucinationAsync(
            PackageVulnerability vulnerability,
            CancellationToken cancellationToken = default)
        {
            try
            {
                var result = await _hallucinationService.CheckForHallucinationAsync(
                    vulnerability.PackageName,
                    vulnerability.PackageManager,
                    vulnerability.Version,
                    cancellationToken);

                if (result.IsHallucinated)
                {
                    vulnerability.IsPotentiallyHallucinated = true;
                    vulnerability.HallucinationConfidence = result.Confidence;
                    vulnerability.HallucinationReason = result.Reason;
                    vulnerability.PackageExists = false;
                    
                    // Update severity if hallucination is detected
                    if (vulnerability.Severity < result.Severity)
                    {
                        vulnerability.Severity = result.Severity;
                    }
                    
                    // Update description
                    vulnerability.Description = string.IsNullOrEmpty(vulnerability.Description)
                        ? $"AI Hallucination Detected: {result.Reason}"
                        : $"{vulnerability.Description} | AI Hallucination: {result.Reason}";
                }
                else
                {
                    vulnerability.PackageExists = result.ExistsInRegistry;
                    
                    // Still flag if there are suspicious patterns
                    if (result.PatternMatchScore > 0.5m || result.TyposquattingRisk > 0.5m)
                    {
                        vulnerability.IsPotentiallyHallucinated = true;
                        vulnerability.HallucinationConfidence = result.Confidence;
                        vulnerability.HallucinationReason = string.Join("; ", result.SuspiciousPatterns);
                    }
                }

                vulnerability.LastCheckedAt = DateTime.UtcNow;
                
                return vulnerability;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error checking hallucination for package {Package}", 
                    vulnerability.PackageName);
                return vulnerability;
            }
        }

        public async Task<List<PackageVulnerability>> GetVulnerabilitiesForScanAsync(
            Guid scanId,
            CancellationToken cancellationToken = default)
        {
            var vulnerabilities = await _unitOfWork.GetRepository<PackageVulnerability>()
                .FindAsync(v => v.SecurityScanId == scanId, cancellationToken);
            
            return vulnerabilities.OrderByDescending(v => v.Severity)
                .ThenByDescending(v => v.HallucinationConfidence)
                .ToList();
        }

        public async Task<List<PackageVulnerability>> ScanDirectoryAsync(
            string directoryPath,
            Guid scanId,
            CancellationToken cancellationToken = default)
        {
            var allVulnerabilities = new List<PackageVulnerability>();

            try
            {
                // Scan for C# project files
                var csprojFiles = Directory.GetFiles(directoryPath, "*.csproj", SearchOption.AllDirectories);
                foreach (var csproj in csprojFiles)
                {
                    var vulnerabilities = await ScanNuGetPackagesAsync(csproj, scanId, cancellationToken);
                    allVulnerabilities.AddRange(vulnerabilities);
                }

                // Scan for package.json files
                var packageJsonFiles = Directory.GetFiles(directoryPath, "package.json", SearchOption.AllDirectories);
                foreach (var packageJson in packageJsonFiles)
                {
                    // Skip node_modules directories
                    if (packageJson.Contains("node_modules")) continue;
                    
                    var vulnerabilities = await ScanNpmPackagesAsync(packageJson, scanId, cancellationToken);
                    allVulnerabilities.AddRange(vulnerabilities);
                }

                // Scan for requirements.txt files
                var requirementsFiles = Directory.GetFiles(directoryPath, "requirements.txt", SearchOption.AllDirectories);
                foreach (var requirements in requirementsFiles)
                {
                    var vulnerabilities = await ScanPythonPackagesAsync(requirements, scanId, cancellationToken);
                    allVulnerabilities.AddRange(vulnerabilities);
                }

                _logger.LogInformation("Directory scan complete. Found {Count} total vulnerabilities", 
                    allVulnerabilities.Count);

                return allVulnerabilities;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error scanning directory {Directory}", directoryPath);
                throw;
            }
        }
    }
}