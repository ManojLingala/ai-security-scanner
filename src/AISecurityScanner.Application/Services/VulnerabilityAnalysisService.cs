using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using AutoMapper;
using Microsoft.Extensions.Logging;
using AISecurityScanner.Application.DTOs;
using AISecurityScanner.Application.Interfaces;
using AISecurityScanner.Application.Models;
using AISecurityScanner.Domain.Entities;
using AISecurityScanner.Domain.Enums;
using AISecurityScanner.Domain.Interfaces;

namespace AISecurityScanner.Application.Services
{
    public class VulnerabilityAnalysisService : IVulnerabilityAnalysisService
    {
        private readonly IUnitOfWork _unitOfWork;
        private readonly IMapper _mapper;
        private readonly ILogger<VulnerabilityAnalysisService> _logger;

        public VulnerabilityAnalysisService(
            IUnitOfWork unitOfWork,
            IMapper mapper,
            ILogger<VulnerabilityAnalysisService> logger)
        {
            _unitOfWork = unitOfWork;
            _mapper = mapper;
            _logger = logger;
        }

        public async Task<PagedResult<VulnerabilityDto>> GetVulnerabilitiesAsync(Guid organizationId, VulnerabilityFilter filter, PaginationRequest pagination, CancellationToken cancellationToken = default)
        {
            // Get all scans for the organization
            var scans = await _unitOfWork.SecurityScans.FindAsync(
                s => s.Repository.OrganizationId == organizationId,
                cancellationToken);

            var scanIds = scans.Select(s => s.Id).ToList();

            // Get vulnerabilities for those scans
            var vulnerabilities = await _unitOfWork.Vulnerabilities.FindAsync(
                v => scanIds.Contains(v.SecurityScanId),
                cancellationToken);

            // Apply filters
            if (filter.Severity.HasValue)
            {
                vulnerabilities = vulnerabilities.Where(v => v.Severity == filter.Severity.Value);
            }

            if (filter.Status.HasValue)
            {
                vulnerabilities = vulnerabilities.Where(v => v.Status == filter.Status.Value);
            }

            if (filter.IsAIGenerated.HasValue)
            {
                vulnerabilities = vulnerabilities.Where(v => v.IsAIGenerated == filter.IsAIGenerated.Value);
            }

            if (!string.IsNullOrEmpty(filter.Type))
            {
                vulnerabilities = vulnerabilities.Where(v => v.Type.Contains(filter.Type, StringComparison.OrdinalIgnoreCase));
            }

            if (filter.RepositoryId.HasValue)
            {
                var repoScanIds = scans.Where(s => s.RepositoryId == filter.RepositoryId.Value).Select(s => s.Id);
                vulnerabilities = vulnerabilities.Where(v => repoScanIds.Contains(v.SecurityScanId));
            }

            if (filter.FromDate.HasValue)
            {
                vulnerabilities = vulnerabilities.Where(v => v.CreatedAt >= filter.FromDate.Value);
            }

            if (filter.ToDate.HasValue)
            {
                vulnerabilities = vulnerabilities.Where(v => v.CreatedAt <= filter.ToDate.Value);
            }

            if (!string.IsNullOrEmpty(filter.SearchTerm))
            {
                vulnerabilities = vulnerabilities.Where(v =>
                    v.Description.Contains(filter.SearchTerm, StringComparison.OrdinalIgnoreCase) ||
                    v.FilePath.Contains(filter.SearchTerm, StringComparison.OrdinalIgnoreCase) ||
                    v.Type.Contains(filter.SearchTerm, StringComparison.OrdinalIgnoreCase));
            }

            var totalCount = vulnerabilities.Count();
            var pagedVulnerabilities = vulnerabilities
                .OrderByDescending(v => v.CreatedAt)
                .Skip((pagination.PageNumber - 1) * pagination.PageSize)
                .Take(pagination.PageSize);

            return new PagedResult<VulnerabilityDto>
            {
                Items = _mapper.Map<IEnumerable<VulnerabilityDto>>(pagedVulnerabilities),
                TotalCount = totalCount,
                PageNumber = pagination.PageNumber,
                PageSize = pagination.PageSize
            };
        }

        public async Task<VulnerabilityDto?> GetVulnerabilityAsync(Guid vulnerabilityId, CancellationToken cancellationToken = default)
        {
            var vulnerability = await _unitOfWork.Vulnerabilities.GetByIdAsync(vulnerabilityId, cancellationToken);
            return vulnerability != null ? _mapper.Map<VulnerabilityDto>(vulnerability) : null;
        }

        public async Task<bool> UpdateVulnerabilityStatusAsync(Guid vulnerabilityId, VulnerabilityStatus status, Guid userId, string? reason = null, CancellationToken cancellationToken = default)
        {
            try
            {
                var vulnerability = await _unitOfWork.Vulnerabilities.GetByIdAsync(vulnerabilityId, cancellationToken);
                if (vulnerability == null)
                {
                    return false;
                }

                vulnerability.Status = status;
                vulnerability.ReviewedByUserId = userId;
                vulnerability.ReviewedAt = DateTime.UtcNow;
                vulnerability.ModifiedAt = DateTime.UtcNow;

                if (!string.IsNullOrEmpty(reason))
                {
                    vulnerability.FalsePositiveReason = reason;
                }

                await _unitOfWork.Vulnerabilities.UpdateAsync(vulnerability, cancellationToken);
                await _unitOfWork.SaveChangesAsync(cancellationToken);

                _logger.LogInformation("Vulnerability {VulnerabilityId} status updated to {Status} by user {UserId}", 
                    vulnerabilityId, status, userId);

                return true;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error updating vulnerability status for {VulnerabilityId}", vulnerabilityId);
                return false;
            }
        }

        public async Task<bool> MarkAsFalsePositiveAsync(Guid vulnerabilityId, Guid userId, string reason, CancellationToken cancellationToken = default)
        {
            try
            {
                var vulnerability = await _unitOfWork.Vulnerabilities.GetByIdAsync(vulnerabilityId, cancellationToken);
                if (vulnerability == null)
                {
                    return false;
                }

                vulnerability.Status = VulnerabilityStatus.FalsePositive;
                vulnerability.IsFalsePositive = true;
                vulnerability.FalsePositiveReason = reason;
                vulnerability.ReviewedByUserId = userId;
                vulnerability.ReviewedAt = DateTime.UtcNow;
                vulnerability.ModifiedAt = DateTime.UtcNow;

                await _unitOfWork.Vulnerabilities.UpdateAsync(vulnerability, cancellationToken);
                await _unitOfWork.SaveChangesAsync(cancellationToken);

                _logger.LogInformation("Vulnerability {VulnerabilityId} marked as false positive by user {UserId}", 
                    vulnerabilityId, userId);

                return true;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error marking vulnerability as false positive {VulnerabilityId}", vulnerabilityId);
                return false;
            }
        }

        public async Task<VulnerabilityTrendData> GetVulnerabilityTrendsAsync(Guid organizationId, DateTime from, DateTime to, CancellationToken cancellationToken = default)
        {
            var scans = await _unitOfWork.SecurityScans.FindAsync(
                s => s.Repository.OrganizationId == organizationId && s.StartedAt >= from && s.StartedAt <= to,
                cancellationToken);

            var scanIds = scans.Select(s => s.Id).ToList();

            var vulnerabilities = await _unitOfWork.Vulnerabilities.FindAsync(
                v => scanIds.Contains(v.SecurityScanId),
                cancellationToken);

            var trendData = new VulnerabilityTrendData
            {
                VulnerabilitiesByDate = vulnerabilities
                    .GroupBy(v => v.CreatedAt.Date)
                    .ToDictionary(g => g.Key, g => g.Count()),

                VulnerabilitiesBySeverity = vulnerabilities
                    .GroupBy(v => v.Severity)
                    .ToDictionary(g => g.Key, g => g.Count()),

                VulnerabilitiesByType = vulnerabilities
                    .GroupBy(v => v.Type)
                    .ToDictionary(g => g.Key, g => g.Count())
            };

            // Calculate trend percentage
            var halfwayPoint = from.AddDays((to - from).TotalDays / 2);
            var firstHalf = vulnerabilities.Count(v => v.CreatedAt <= halfwayPoint);
            var secondHalf = vulnerabilities.Count(v => v.CreatedAt > halfwayPoint);

            if (firstHalf > 0)
            {
                trendData.TrendPercentage = ((decimal)(secondHalf - firstHalf) / firstHalf) * 100;
                trendData.IsIncreasing = secondHalf > firstHalf;
            }

            return trendData;
        }

        public async Task<VulnerabilitySummary> GetVulnerabilitySummaryAsync(Guid organizationId, CancellationToken cancellationToken = default)
        {
            var scans = await _unitOfWork.SecurityScans.FindAsync(
                s => s.Repository.OrganizationId == organizationId,
                cancellationToken);

            var scanIds = scans.Select(s => s.Id).ToList();

            var vulnerabilities = await _unitOfWork.Vulnerabilities.FindAsync(
                v => scanIds.Contains(v.SecurityScanId),
                cancellationToken);

            var totalVulns = vulnerabilities.Count();
            var aiGeneratedVulns = vulnerabilities.Count(v => v.IsAIGenerated);

            return new VulnerabilitySummary
            {
                TotalVulnerabilities = totalVulns,
                OpenVulnerabilities = vulnerabilities.Count(v => v.Status == VulnerabilityStatus.Open),
                ResolvedVulnerabilities = vulnerabilities.Count(v => v.Status == VulnerabilityStatus.Resolved),
                FalsePositives = vulnerabilities.Count(v => v.Status == VulnerabilityStatus.FalsePositive),
                
                BySeverity = vulnerabilities
                    .GroupBy(v => v.Severity)
                    .ToDictionary(g => g.Key, g => g.Count()),

                ByType = vulnerabilities
                    .GroupBy(v => v.Type)
                    .ToDictionary(g => g.Key, g => g.Count()),

                AIGeneratedVulnerabilities = aiGeneratedVulns,
                AIVulnerabilityPercentage = totalVulns > 0 ? (decimal)aiGeneratedVulns / totalVulns * 100 : 0
            };
        }

        public async Task<List<VulnerabilityDto>> GetSimilarVulnerabilitiesAsync(Guid vulnerabilityId, CancellationToken cancellationToken = default)
        {
            var vulnerability = await _unitOfWork.Vulnerabilities.GetByIdAsync(vulnerabilityId, cancellationToken);
            if (vulnerability == null)
            {
                return new List<VulnerabilityDto>();
            }

            // Find similar vulnerabilities based on type and file path patterns
            var similarVulns = await _unitOfWork.Vulnerabilities.FindAsync(
                v => v.Id != vulnerabilityId && 
                     v.Type == vulnerability.Type &&
                     (v.FilePath.Contains(System.IO.Path.GetFileNameWithoutExtension(vulnerability.FilePath)) ||
                      Math.Abs(v.LineNumber - vulnerability.LineNumber) < 10),
                cancellationToken);

            return _mapper.Map<List<VulnerabilityDto>>(similarVulns.Take(10));
        }

        public async Task<ComplianceReport> GenerateComplianceReportAsync(Guid organizationId, ComplianceStandard standard, CancellationToken cancellationToken = default)
        {
            var scans = await _unitOfWork.SecurityScans.FindAsync(
                s => s.Repository.OrganizationId == organizationId,
                cancellationToken);

            var scanIds = scans.Select(s => s.Id).ToList();

            var vulnerabilities = await _unitOfWork.Vulnerabilities.FindAsync(
                v => scanIds.Contains(v.SecurityScanId) && v.Status == VulnerabilityStatus.Open,
                cancellationToken);

            var report = new ComplianceReport
            {
                Standard = standard,
                GeneratedAt = DateTime.UtcNow,
                Items = GenerateComplianceItems(standard, vulnerabilities)
            };

            // Calculate compliance score
            var totalItems = report.Items.Count;
            var compliantItems = report.Items.Count(i => i.IsCompliant);
            report.ComplianceScore = totalItems > 0 ? (decimal)compliantItems / totalItems * 100 : 100;

            return report;
        }

        private List<ComplianceItem> GenerateComplianceItems(ComplianceStandard standard, IEnumerable<Vulnerability> vulnerabilities)
        {
            var items = new List<ComplianceItem>();

            switch (standard)
            {
                case ComplianceStandard.OWASP:
                    items.AddRange(GenerateOWASPComplianceItems(vulnerabilities));
                    break;
                case ComplianceStandard.CWE:
                    items.AddRange(GenerateCWEComplianceItems(vulnerabilities));
                    break;
                case ComplianceStandard.NIST:
                    items.AddRange(GenerateNISTComplianceItems(vulnerabilities));
                    break;
                case ComplianceStandard.ISO27001:
                    items.AddRange(GenerateISO27001ComplianceItems(vulnerabilities));
                    break;
                case ComplianceStandard.SOC2:
                    items.AddRange(GenerateSOC2ComplianceItems(vulnerabilities));
                    break;
            }

            return items;
        }

        private List<ComplianceItem> GenerateOWASPComplianceItems(IEnumerable<Vulnerability> vulnerabilities)
        {
            var owaspCategories = new[]
            {
                "A01:2021-Broken Access Control",
                "A02:2021-Cryptographic Failures", 
                "A03:2021-Injection",
                "A04:2021-Insecure Design",
                "A05:2021-Security Misconfiguration",
                "A06:2021-Vulnerable and Outdated Components",
                "A07:2021-Identification and Authentication Failures",
                "A08:2021-Software and Data Integrity Failures",
                "A09:2021-Security Logging and Monitoring Failures",
                "A10:2021-Server-Side Request Forgery"
            };

            return owaspCategories.Select(category =>
            {
                var categoryVulns = vulnerabilities
                    .Where(v => v.OWASPCategory?.Contains(category.Split(':')[0]) == true)
                    .ToList();

                return new ComplianceItem
                {
                    Requirement = category,
                    IsCompliant = !categoryVulns.Any(),
                    RelatedVulnerabilities = _mapper.Map<List<VulnerabilityDto>>(categoryVulns),
                    Recommendation = categoryVulns.Any() 
                        ? $"Address {categoryVulns.Count} vulnerabilities in category {category}"
                        : "No vulnerabilities found in this category"
                };
            }).ToList();
        }

        private List<ComplianceItem> GenerateCWEComplianceItems(IEnumerable<Vulnerability> vulnerabilities)
        {
            var cweGroups = vulnerabilities
                .Where(v => !string.IsNullOrEmpty(v.CWE))
                .GroupBy(v => v.CWE)
                .ToList();

            return cweGroups.Select(group => new ComplianceItem
            {
                Requirement = $"CWE-{group.Key}: No instances of this weakness",
                IsCompliant = false, // If we found instances, we're not compliant
                RelatedVulnerabilities = _mapper.Map<List<VulnerabilityDto>>(group.ToList()),
                Recommendation = $"Address {group.Count()} instances of {group.Key}"
            }).ToList();
        }

        private List<ComplianceItem> GenerateNISTComplianceItems(IEnumerable<Vulnerability> vulnerabilities)
        {
            // Simplified NIST compliance mapping
            var criticalVulns = vulnerabilities.Where(v => v.Severity == VulnerabilitySeverity.Critical).ToList();
            var highVulns = vulnerabilities.Where(v => v.Severity == VulnerabilitySeverity.High).ToList();

            return new List<ComplianceItem>
            {
                new ComplianceItem
                {
                    Requirement = "SC-1: System and Communications Protection Policy",
                    IsCompliant = !criticalVulns.Any(),
                    RelatedVulnerabilities = _mapper.Map<List<VulnerabilityDto>>(criticalVulns),
                    Recommendation = criticalVulns.Any() 
                        ? "Address critical security vulnerabilities"
                        : "No critical vulnerabilities found"
                },
                new ComplianceItem
                {
                    Requirement = "SI-2: Flaw Remediation",
                    IsCompliant = !highVulns.Any(),
                    RelatedVulnerabilities = _mapper.Map<List<VulnerabilityDto>>(highVulns),
                    Recommendation = highVulns.Any() 
                        ? "Address high severity vulnerabilities"
                        : "No high severity vulnerabilities found"
                }
            };
        }

        private List<ComplianceItem> GenerateISO27001ComplianceItems(IEnumerable<Vulnerability> vulnerabilities)
        {
            // Simplified ISO 27001 compliance
            var allVulns = vulnerabilities.ToList();
            
            return new List<ComplianceItem>
            {
                new ComplianceItem
                {
                    Requirement = "A.12.6.1: Management of technical vulnerabilities",
                    IsCompliant = !allVulns.Any(),
                    RelatedVulnerabilities = _mapper.Map<List<VulnerabilityDto>>(allVulns),
                    Recommendation = allVulns.Any() 
                        ? "Implement vulnerability management process"
                        : "Vulnerability management requirements met"
                }
            };
        }

        private List<ComplianceItem> GenerateSOC2ComplianceItems(IEnumerable<Vulnerability> vulnerabilities)
        {
            // Simplified SOC 2 compliance
            var securityVulns = vulnerabilities.Where(v => 
                v.Severity >= VulnerabilitySeverity.Medium).ToList();

            return new List<ComplianceItem>
            {
                new ComplianceItem
                {
                    Requirement = "CC6.1: Logical and physical access controls",
                    IsCompliant = !securityVulns.Any(),
                    RelatedVulnerabilities = _mapper.Map<List<VulnerabilityDto>>(securityVulns),
                    Recommendation = securityVulns.Any() 
                        ? "Address medium+ severity vulnerabilities for SOC 2 compliance"
                        : "Access control requirements met"
                }
            };
        }
    }
}