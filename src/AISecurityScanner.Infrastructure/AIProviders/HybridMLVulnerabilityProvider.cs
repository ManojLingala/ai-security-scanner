using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.Http;
using System.Text;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using AISecurityScanner.Application.Interfaces;
using AISecurityScanner.Domain.Enums;
using AISecurityScanner.Domain.ValueObjects;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;

namespace AISecurityScanner.Infrastructure.AIProviders
{
    public class HybridMLVulnerabilityProvider : IAIProvider
    {
        private readonly HttpClient _httpClient;
        private readonly ILogger<HybridMLVulnerabilityProvider> _logger;
        private readonly IConfiguration _configuration;
        private readonly MLVulnerabilityProvider _localMLProvider;
        private readonly string? _codeGuruApiKey;
        private readonly string? _snykApiKey;

        public string Name => "Hybrid-ML-Detector";
        public decimal CostPerRequest => 0.05m; // Higher cost due to external API usage
        public TimeSpan TypicalResponseTime => TimeSpan.FromSeconds(2);
        public bool SupportsCodeAnalysis => true;
        public bool SupportsPackageValidation => true;

        public HybridMLVulnerabilityProvider(
            HttpClient httpClient,
            ILogger<HybridMLVulnerabilityProvider> logger,
            IConfiguration configuration,
            MLVulnerabilityProvider localMLProvider)
        {
            _httpClient = httpClient;
            _logger = logger;
            _configuration = configuration;
            _localMLProvider = localMLProvider;
            _codeGuruApiKey = configuration["AIProviders:CodeGuru:ApiKey"];
            _snykApiKey = configuration["AIProviders:Snyk:ApiKey"];
        }

        public async Task<SecurityAnalysisResult> AnalyzeCodeAsync(
            string code, 
            AIAnalysisContext context, 
            CancellationToken cancellationToken = default)
        {
            var startTime = DateTime.UtcNow;
            var allVulnerabilities = new List<SecurityVulnerability>();
            var analysisResults = new List<SecurityAnalysisResult>();

            try
            {
                // 1. Run local ML analysis first (fastest)
                var localResult = await _localMLProvider.AnalyzeCodeAsync(code, context, cancellationToken);
                if (localResult.IsSuccess)
                {
                    analysisResults.Add(localResult);
                    allVulnerabilities.AddRange(localResult.DetectedVulnerabilities);
                }

                // 2. Run external API analyses in parallel if configured
                var externalTasks = new List<Task<SecurityAnalysisResult>>();
                
                if (!string.IsNullOrEmpty(_codeGuruApiKey))
                {
                    externalTasks.Add(AnalyzeWithCodeGuruAsync(code, context, cancellationToken));
                }
                
                if (!string.IsNullOrEmpty(_snykApiKey))
                {
                    externalTasks.Add(AnalyzeWithSnykAsync(code, context, cancellationToken));
                }

                // Wait for all external analyses to complete
                if (externalTasks.Any())
                {
                    var externalResults = await Task.WhenAll(externalTasks);
                    foreach (var result in externalResults.Where(r => r.IsSuccess))
                    {
                        analysisResults.Add(result);
                        allVulnerabilities.AddRange(result.DetectedVulnerabilities);
                    }
                }

                // 3. Merge and deduplicate vulnerabilities
                var mergedVulnerabilities = MergeVulnerabilities(allVulnerabilities);

                // 4. Apply ensemble scoring
                var ensembleVulnerabilities = ApplyEnsembleScoring(mergedVulnerabilities, analysisResults.Count);

                return new SecurityAnalysisResult
                {
                    IsSuccess = true,
                    ProviderName = Name,
                    DetectedVulnerabilities = ensembleVulnerabilities,
                    ConfidenceScore = CalculateEnsembleConfidence(ensembleVulnerabilities),
                    ResponseTime = DateTime.UtcNow - startTime,
                    TokensUsed = analysisResults.Sum(r => r.TokensUsed),
                    Cost = analysisResults.Sum(r => r.Cost),
                    MLModelUsed = $"Ensemble({string.Join(",", analysisResults.Select(r => r.MLModelUsed ?? r.ProviderName))})",
                    AnalysisMetadata = new Dictionary<string, object>
                    {
                        ["ProvidersUsed"] = analysisResults.Count,
                        ["LocalDetections"] = localResult.DetectedVulnerabilities.Count,
                        ["ExternalDetections"] = allVulnerabilities.Count - localResult.DetectedVulnerabilities.Count,
                        ["TotalBeforeMerge"] = allVulnerabilities.Count,
                        ["TotalAfterMerge"] = ensembleVulnerabilities.Count
                    }
                };
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error during hybrid ML vulnerability analysis");
                
                // Fallback to local analysis only
                if (analysisResults.Any())
                {
                    var bestResult = analysisResults.OrderByDescending(r => r.ConfidenceScore).First();
                    bestResult.AnalysisMetadata["FallbackMode"] = true;
                    bestResult.AnalysisMetadata["ErrorMessage"] = ex.Message;
                    return bestResult;
                }

                return new SecurityAnalysisResult
                {
                    IsSuccess = false,
                    ErrorMessage = ex.Message,
                    ProviderName = Name,
                    ResponseTime = DateTime.UtcNow - startTime
                };
            }
        }

        public async Task<PackageValidationResult> ValidatePackagesAsync(
            List<string> packages, 
            string ecosystem, 
            CancellationToken cancellationToken = default)
        {
            try
            {
                var results = new List<PackageValidationResult>();

                // Use local ML provider
                var localResult = await _localMLProvider.ValidatePackagesAsync(packages, ecosystem, cancellationToken);
                if (localResult.IsSuccess)
                {
                    results.Add(localResult);
                }

                // Add Snyk package validation if available
                if (!string.IsNullOrEmpty(_snykApiKey))
                {
                    var snykResult = await ValidatePackagesWithSnykAsync(packages, ecosystem, cancellationToken);
                    if (snykResult.IsSuccess)
                    {
                        results.Add(snykResult);
                    }
                }

                // Merge results
                var allVulnerablePackages = results.SelectMany(r => r.VulnerablePackages).ToList();
                var mergedPackages = MergePackageVulnerabilities(allVulnerablePackages);

                return new PackageValidationResult
                {
                    IsSuccess = true,
                    VulnerablePackages = mergedPackages,
                    TotalPackagesScanned = packages.Count,
                    VulnerablePackageCount = mergedPackages.Count(p => p.HasVulnerabilities),
                    Cost = results.Sum(r => r.Cost),
                    ProviderName = Name
                };
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error during hybrid package validation");
                return new PackageValidationResult
                {
                    IsSuccess = false,
                    ErrorMessage = ex.Message
                };
            }
        }

        public async Task<bool> IsHealthyAsync(CancellationToken cancellationToken = default)
        {
            // Check if at least local ML provider is healthy
            return await _localMLProvider.IsHealthyAsync(cancellationToken);
        }

        public async Task<ProviderHealthStatus> GetHealthStatusAsync(CancellationToken cancellationToken = default)
        {
            var localHealth = await _localMLProvider.GetHealthStatusAsync(cancellationToken);
            var startTime = DateTime.UtcNow;

            var externalHealthChecks = new List<Task<bool>>();
            
            if (!string.IsNullOrEmpty(_codeGuruApiKey))
            {
                externalHealthChecks.Add(CheckCodeGuruHealthAsync(cancellationToken));
            }
            
            if (!string.IsNullOrEmpty(_snykApiKey))
            {
                externalHealthChecks.Add(CheckSnykHealthAsync(cancellationToken));
            }

            var externalResults = externalHealthChecks.Any() 
                ? await Task.WhenAll(externalHealthChecks) 
                : Array.Empty<bool>();

            var overallHealth = localHealth.IsHealthy && externalResults.All(r => r);
            
            return new ProviderHealthStatus
            {
                IsHealthy = overallHealth,
                ResponseTime = DateTime.UtcNow - startTime,
                CheckedAt = DateTime.UtcNow,
                SuccessRate = overallHealth ? 1.0m : 0.5m,
                ErrorMessage = overallHealth ? null : "Some external services are unavailable"
            };
        }

        private async Task<SecurityAnalysisResult> AnalyzeWithCodeGuruAsync(
            string code, 
            AIAnalysisContext context, 
            CancellationToken cancellationToken)
        {
            try
            {
                // This is a mock implementation - in real scenario, you'd integrate with actual CodeGuru API
                _logger.LogInformation("Analyzing code with CodeGuru (mock)");
                
                await Task.Delay(1000, cancellationToken); // Simulate API call
                
                return new SecurityAnalysisResult
                {
                    IsSuccess = true,
                    ProviderName = "CodeGuru",
                    DetectedVulnerabilities = new List<SecurityVulnerability>(),
                    ConfidenceScore = 0.95m,
                    ResponseTime = TimeSpan.FromMilliseconds(1000),
                    TokensUsed = 100,
                    Cost = 0.03m,
                    MLModelUsed = "CodeGuru-ML"
                };
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error analyzing with CodeGuru");
                return new SecurityAnalysisResult
                {
                    IsSuccess = false,
                    ErrorMessage = ex.Message,
                    ProviderName = "CodeGuru"
                };
            }
        }

        private async Task<SecurityAnalysisResult> AnalyzeWithSnykAsync(
            string code, 
            AIAnalysisContext context, 
            CancellationToken cancellationToken)
        {
            try
            {
                // Mock implementation for Snyk Code analysis
                _logger.LogInformation("Analyzing code with Snyk (mock)");
                
                await Task.Delay(800, cancellationToken);
                
                return new SecurityAnalysisResult
                {
                    IsSuccess = true,
                    ProviderName = "Snyk",
                    DetectedVulnerabilities = new List<SecurityVulnerability>(),
                    ConfidenceScore = 0.90m,
                    ResponseTime = TimeSpan.FromMilliseconds(800),
                    TokensUsed = 80,
                    Cost = 0.02m,
                    MLModelUsed = "Snyk-ML"
                };
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error analyzing with Snyk");
                return new SecurityAnalysisResult
                {
                    IsSuccess = false,
                    ErrorMessage = ex.Message,
                    ProviderName = "Snyk"
                };
            }
        }

        private async Task<PackageValidationResult> ValidatePackagesWithSnykAsync(
            List<string> packages, 
            string ecosystem, 
            CancellationToken cancellationToken)
        {
            try
            {
                // Mock Snyk package validation
                await Task.Delay(500, cancellationToken);
                
                return new PackageValidationResult
                {
                    IsSuccess = true,
                    VulnerablePackages = new List<PackageVulnerabilityInfo>(),
                    TotalPackagesScanned = packages.Count,
                    VulnerablePackageCount = 0,
                    Cost = 0.01m * packages.Count,
                    ProviderName = "Snyk"
                };
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error validating packages with Snyk");
                return new PackageValidationResult
                {
                    IsSuccess = false,
                    ErrorMessage = ex.Message
                };
            }
        }

        private async Task<bool> CheckCodeGuruHealthAsync(CancellationToken cancellationToken)
        {
            try
            {
                // Mock health check
                await Task.Delay(100, cancellationToken);
                return true;
            }
            catch
            {
                return false;
            }
        }

        private async Task<bool> CheckSnykHealthAsync(CancellationToken cancellationToken)
        {
            try
            {
                // Mock health check
                await Task.Delay(100, cancellationToken);
                return true;
            }
            catch
            {
                return false;
            }
        }

        private List<SecurityVulnerability> MergeVulnerabilities(List<SecurityVulnerability> vulnerabilities)
        {
            var groups = vulnerabilities
                .GroupBy(v => new { v.Type, v.LineNumber, v.CweId })
                .Select(g => CreateMergedVulnerability(g.ToList()))
                .ToList();

            return groups;
        }

        private SecurityVulnerability CreateMergedVulnerability(List<SecurityVulnerability> duplicates)
        {
            var primary = duplicates.OrderByDescending(v => v.Confidence).First();
            
            return new SecurityVulnerability
            {
                Id = primary.Id,
                Type = primary.Type,
                Severity = duplicates.Max(v => v.Severity),
                Confidence = duplicates.Average(v => v.Confidence),
                Description = primary.Description,
                LineNumber = primary.LineNumber,
                Code = primary.Code,
                CweId = primary.CweId,
                Recommendation = primary.Recommendation,
                MLDetected = true,
                DetectedAt = primary.DetectedAt,
                Metadata = new Dictionary<string, object>
                {
                    ["DetectionCount"] = duplicates.Count,
                    ["DetectedBy"] = duplicates.Select(v => v.Metadata.GetValueOrDefault("DetectedBy", "Unknown")).Distinct().ToList(),
                    ["ConfidenceRange"] = $"{duplicates.Min(v => v.Confidence):F2}-{duplicates.Max(v => v.Confidence):F2}"
                }
            };
        }

        private List<SecurityVulnerability> ApplyEnsembleScoring(List<SecurityVulnerability> vulnerabilities, int providerCount)
        {
            foreach (var vuln in vulnerabilities)
            {
                var detectionCount = (int)(vuln.Metadata.GetValueOrDefault("DetectionCount", 1));
                var ensembleBoost = Math.Min(0.3m, (detectionCount - 1) * 0.1m);
                vuln.Confidence = Math.Min(1.0m, vuln.Confidence + ensembleBoost);
                
                vuln.Metadata["EnsembleScore"] = vuln.Confidence;
                vuln.Metadata["ProvidersUsed"] = providerCount;
            }

            return vulnerabilities.Where(v => v.Confidence >= 0.4m).ToList();
        }

        private decimal CalculateEnsembleConfidence(List<SecurityVulnerability> vulnerabilities)
        {
            if (!vulnerabilities.Any()) return 1.0m;
            
            return vulnerabilities.Average(v => v.Confidence);
        }

        private List<PackageVulnerabilityInfo> MergePackageVulnerabilities(List<PackageVulnerabilityInfo> packages)
        {
            return packages
                .GroupBy(p => p.PackageName)
                .Select(g => new PackageVulnerabilityInfo
                {
                    PackageName = g.Key,
                    Ecosystem = g.First().Ecosystem,
                    HasVulnerabilities = g.Any(p => p.HasVulnerabilities),
                    Vulnerabilities = g.SelectMany(p => p.Vulnerabilities).Distinct().ToList()
                })
                .ToList();
        }
    }
}