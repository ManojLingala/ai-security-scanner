using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.Http;
using System.Text;
using System.Text.Json;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using AISecurityScanner.Application.Interfaces;
using AISecurityScanner.Domain.Enums;
using AISecurityScanner.Domain.ValueObjects;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;

namespace AISecurityScanner.Infrastructure.AIProviders
{
    public class MLVulnerabilityProvider : IAIProvider
    {
        private readonly HttpClient _httpClient;
        private readonly ILogger<MLVulnerabilityProvider> _logger;
        private readonly IConfiguration _configuration;
        private readonly MLVulnerabilityDetector _detector;

        public string Name => "ML-VulnerabilityDetector";
        public decimal CostPerRequest => 0.001m; // Very low cost for local ML
        public TimeSpan TypicalResponseTime => TimeSpan.FromMilliseconds(500);
        public bool SupportsCodeAnalysis => true;
        public bool SupportsPackageValidation => true;

        public MLVulnerabilityProvider(
            HttpClient httpClient,
            ILogger<MLVulnerabilityProvider> logger,
            IConfiguration configuration)
        {
            _httpClient = httpClient;
            _logger = logger;
            _configuration = configuration;
            _detector = new MLVulnerabilityDetector(logger);
        }

        public async Task<SecurityAnalysisResult> AnalyzeCodeAsync(
            string code, 
            AIAnalysisContext context, 
            CancellationToken cancellationToken = default)
        {
            var startTime = DateTime.UtcNow;
            
            try
            {
                var vulnerabilities = await _detector.DetectVulnerabilitiesAsync(code, context.Language ?? "csharp");
                
                var result = new SecurityAnalysisResult
                {
                    IsSuccess = true,
                    ProviderName = Name,
                    DetectedVulnerabilities = vulnerabilities,
                    ConfidenceScore = CalculateOverallConfidence(vulnerabilities),
                    ResponseTime = DateTime.UtcNow - startTime,
                    TokensUsed = EstimateTokensUsed(code),
                    Cost = CostPerRequest,
                    MLModelUsed = "CustomVulnerabilityDetector",
                    AnalysisMetadata = new Dictionary<string, object>
                    {
                        ["TotalPatterns"] = _detector.TotalPatterns,
                        ["Language"] = context.Language ?? "csharp",
                        ["CodeLength"] = code.Length,
                        ["LinesAnalyzed"] = code.Split('\n').Length
                    }
                };

                _logger.LogInformation("ML analysis completed for {Language} code. Found {Count} vulnerabilities", 
                    context.Language ?? "csharp", vulnerabilities.Count);

                return result;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error during ML vulnerability analysis");
                return new SecurityAnalysisResult
                {
                    IsSuccess = false,
                    ErrorMessage = ex.Message,
                    ProviderName = Name,
                    ResponseTime = DateTime.UtcNow - startTime
                };
            }
        }

        public async Task<PackageValidationResult> ValidatePackagesAsync(
            List<string> packages, 
            string ecosystem, 
            CancellationToken cancellationToken = default)
        {
            try
            {
                var results = new List<PackageVulnerabilityInfo>();
                
                foreach (var package in packages)
                {
                    var packageAnalysis = await _detector.AnalyzePackageAsync(package, ecosystem);
                    if (packageAnalysis != null)
                    {
                        results.Add(packageAnalysis);
                    }
                }

                return new PackageValidationResult
                {
                    IsSuccess = true,
                    VulnerablePackages = results,
                    TotalPackagesScanned = packages.Count,
                    VulnerablePackageCount = results.Count(r => r.HasVulnerabilities),
                    Cost = CostPerRequest * packages.Count,
                    ProviderName = Name
                };
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error during ML package validation");
                return new PackageValidationResult
                {
                    IsSuccess = false,
                    ErrorMessage = ex.Message
                };
            }
        }

        public async Task<bool> IsHealthyAsync(CancellationToken cancellationToken = default)
        {
            try
            {
                // Test ML detector with sample code
                var testCode = "string sql = \"SELECT * FROM users WHERE id = \" + userId;";
                var result = await _detector.DetectVulnerabilitiesAsync(testCode, "csharp");
                return result.Any(); // Should detect SQL injection
            }
            catch
            {
                return false;
            }
        }

        public async Task<ProviderHealthStatus> GetHealthStatusAsync(CancellationToken cancellationToken = default)
        {
            var startTime = DateTime.UtcNow;
            var isHealthy = await IsHealthyAsync(cancellationToken);
            
            return new ProviderHealthStatus
            {
                IsHealthy = isHealthy,
                ResponseTime = DateTime.UtcNow - startTime,
                CheckedAt = DateTime.UtcNow,
                SuccessRate = isHealthy ? 1.0m : 0.0m,
                ErrorMessage = isHealthy ? null : "ML detector failed health check"
            };
        }

        private decimal CalculateOverallConfidence(List<SecurityVulnerability> vulnerabilities)
        {
            if (!vulnerabilities.Any()) return 1.0m;
            
            return vulnerabilities.Average(v => v.Confidence);
        }

        private int EstimateTokensUsed(string code)
        {
            // Rough estimation: 1 token per 4 characters
            return code.Length / 4;
        }
    }

    public class MLVulnerabilityDetector
    {
        private readonly ILogger _logger;
        private readonly Dictionary<string, List<VulnerabilityPattern>> _vulnerabilityPatterns;

        public int TotalPatterns => _vulnerabilityPatterns.Values.Sum(v => v.Count);

        public MLVulnerabilityDetector(ILogger logger)
        {
            _logger = logger;
            _vulnerabilityPatterns = InitializeVulnerabilityPatterns();
        }

        public async Task<List<SecurityVulnerability>> DetectVulnerabilitiesAsync(string code, string language)
        {
            var vulnerabilities = new List<SecurityVulnerability>();
            
            if (!_vulnerabilityPatterns.TryGetValue(language.ToLower(), out var patterns))
            {
                patterns = _vulnerabilityPatterns["general"];
            }

            var lines = code.Split('\n');
            
            for (int lineIndex = 0; lineIndex < lines.Length; lineIndex++)
            {
                var line = lines[lineIndex];
                
                foreach (var pattern in patterns)
                {
                    var matches = pattern.Regex.Matches(line);
                    
                    foreach (Match match in matches)
                    {
                        var vulnerability = CreateVulnerability(pattern, match, lineIndex + 1, line);
                        vulnerabilities.Add(vulnerability);
                    }
                }
            }

            // Apply ML-based confidence scoring and filtering
            vulnerabilities = await ApplyMLConfidenceScoring(vulnerabilities, code, language);
            
            return vulnerabilities.Where(v => v.Confidence >= 0.3m).ToList();
        }

        public async Task<PackageVulnerabilityInfo?> AnalyzePackageAsync(string packageName, string ecosystem)
        {
            // Implement package-specific vulnerability detection
            var suspiciousPatterns = new[]
            {
                @".*test.*\d+$",
                @".*demo.*lib$",
                @".*temp.*package$",
                @".*fake.*module$"
            };

            var isSuspicious = suspiciousPatterns.Any(pattern => 
                Regex.IsMatch(packageName, pattern, RegexOptions.IgnoreCase));

            if (isSuspicious)
            {
                return new PackageVulnerabilityInfo
                {
                    PackageName = packageName,
                    Ecosystem = ecosystem,
                    HasVulnerabilities = true,
                    Vulnerabilities = new List<PackageVulnerability>
                    {
                        new PackageVulnerability
                        {
                            Id = "ML-SUSP-001",
                            Description = "Potentially AI-generated or test package name detected",
                            Severity = VulnerabilitySeverity.Medium,
                            Confidence = 0.8m
                        }
                    }
                };
            }

            return null;
        }

        private Dictionary<string, List<VulnerabilityPattern>> InitializeVulnerabilityPatterns()
        {
            var patterns = new Dictionary<string, List<VulnerabilityPattern>>();

            // C# specific patterns
            patterns["csharp"] = new List<VulnerabilityPattern>
            {
                // SQL Injection patterns
                new VulnerabilityPattern
                {
                    Id = "CWE-89",
                    Name = "SQL Injection",
                    Regex = new Regex(@"(string\s+\w+\s*=\s*""[^""]*""\s*\+\s*\w+|SqlCommand\([^)]*\+[^)]*\))", RegexOptions.IgnoreCase),
                    Severity = VulnerabilitySeverity.Critical,
                    BaseConfidence = 0.9m,
                    Description = "Potential SQL injection vulnerability detected"
                },
                
                // XSS patterns
                new VulnerabilityPattern
                {
                    Id = "CWE-79",
                    Name = "Cross-Site Scripting (XSS)",
                    Regex = new Regex(@"(Response\.Write\([^)]*\+[^)]*\)|@Html\.Raw\([^)]*\))", RegexOptions.IgnoreCase),
                    Severity = VulnerabilitySeverity.High,
                    BaseConfidence = 0.8m,
                    Description = "Potential XSS vulnerability detected"
                },
                
                // Command Injection
                new VulnerabilityPattern
                {
                    Id = "CWE-78",
                    Name = "Command Injection",
                    Regex = new Regex(@"(Process\.Start\([^)]*\+[^)]*\)|System\.Diagnostics\.Process)", RegexOptions.IgnoreCase),
                    Severity = VulnerabilitySeverity.Critical,
                    BaseConfidence = 0.85m,
                    Description = "Potential command injection vulnerability detected"
                },
                
                // Path Traversal
                new VulnerabilityPattern
                {
                    Id = "CWE-22",
                    Name = "Path Traversal",
                    Regex = new Regex(@"(File\.(ReadAllText|WriteAllText|Copy|Move)\([^)]*\+[^)]*\)|Path\.Combine\([^)]*\+[^)]*\))", RegexOptions.IgnoreCase),
                    Severity = VulnerabilitySeverity.High,
                    BaseConfidence = 0.7m,
                    Description = "Potential path traversal vulnerability detected"
                },
                
                // Hardcoded Secrets
                new VulnerabilityPattern
                {
                    Id = "CWE-798",
                    Name = "Hardcoded Credentials",
                    Regex = new Regex(@"(password\s*=\s*""[^""]+""|(api|secret|token|key)\s*=\s*""[A-Za-z0-9+/=]{20,}"")", RegexOptions.IgnoreCase),
                    Severity = VulnerabilitySeverity.Critical,
                    BaseConfidence = 0.9m,
                    Description = "Hardcoded credentials detected"
                },

                // Insecure Deserialization
                new VulnerabilityPattern
                {
                    Id = "CWE-502",
                    Name = "Insecure Deserialization",
                    Regex = new Regex(@"(BinaryFormatter|JavaScriptSerializer|JsonConvert\.DeserializeObject<object>)", RegexOptions.IgnoreCase),
                    Severity = VulnerabilitySeverity.High,
                    BaseConfidence = 0.75m,
                    Description = "Potentially insecure deserialization detected"
                }
            };

            // General patterns (language agnostic)
            patterns["general"] = new List<VulnerabilityPattern>
            {
                new VulnerabilityPattern
                {
                    Id = "GEN-001",
                    Name = "Suspicious AI Pattern",
                    Regex = new Regex(@"(TODO:\s*implement|placeholder|example|demo|test.*function)", RegexOptions.IgnoreCase),
                    Severity = VulnerabilitySeverity.Low,
                    BaseConfidence = 0.6m,
                    Description = "Potentially AI-generated placeholder code"
                }
            };

            return patterns;
        }

        private SecurityVulnerability CreateVulnerability(
            VulnerabilityPattern pattern, 
            Match match, 
            int lineNumber, 
            string lineContent)
        {
            return new SecurityVulnerability
            {
                Id = $"{pattern.Id}-{Guid.NewGuid():N}",
                Type = pattern.Name,
                Severity = pattern.Severity,
                Confidence = pattern.BaseConfidence,
                Description = pattern.Description,
                LineNumber = lineNumber,
                Code = lineContent.Trim(),
                CweId = pattern.Id,
                Recommendation = GetRecommendation(pattern.Id),
                MLDetected = true
            };
        }

        private async Task<List<SecurityVulnerability>> ApplyMLConfidenceScoring(
            List<SecurityVulnerability> vulnerabilities,
            string code,
            string language)
        {
            // Apply contextual analysis to adjust confidence scores
            foreach (var vuln in vulnerabilities)
            {
                // Contextual factors that affect confidence
                var contextualFactors = AnalyzeContext(vuln, code);
                
                // Adjust confidence based on context
                vuln.Confidence = AdjustConfidenceScore(vuln.Confidence, contextualFactors);
                
                // Add reasoning for confidence adjustment
                if (contextualFactors.Any())
                {
                    vuln.Description += $" (Confidence adjusted by: {string.Join(", ", contextualFactors)})";
                }
            }

            return vulnerabilities;
        }

        private List<string> AnalyzeContext(SecurityVulnerability vulnerability, string code)
        {
            var factors = new List<string>();
            
            // Check if it's in a comment
            if (vulnerability.Code.TrimStart().StartsWith("//") || 
                vulnerability.Code.TrimStart().StartsWith("/*"))
            {
                factors.Add("in comment");
            }
            
            // Check if it's in a string literal context
            if (vulnerability.Code.Contains("\"") && 
                vulnerability.Code.Split('"').Length > 2)
            {
                factors.Add("in string context");
            }
            
            // Check for validation nearby
            var lines = code.Split('\n');
            var vulnLineIndex = vulnerability.LineNumber - 1;
            
            for (int i = Math.Max(0, vulnLineIndex - 3); 
                 i < Math.Min(lines.Length, vulnLineIndex + 3); i++)
            {
                if (lines[i].Contains("validate", StringComparison.OrdinalIgnoreCase) ||
                    lines[i].Contains("sanitize", StringComparison.OrdinalIgnoreCase) ||
                    lines[i].Contains("encode", StringComparison.OrdinalIgnoreCase))
                {
                    factors.Add("validation nearby");
                    break;
                }
            }
            
            return factors;
        }

        private decimal AdjustConfidenceScore(decimal baseConfidence, List<string> contextualFactors)
        {
            var adjustedConfidence = baseConfidence;
            
            foreach (var factor in contextualFactors)
            {
                adjustedConfidence = factor switch
                {
                    "in comment" => adjustedConfidence * 0.1m, // Very low confidence for comments
                    "in string context" => adjustedConfidence * 0.7m, // Lower confidence
                    "validation nearby" => adjustedConfidence * 0.5m, // Reduced confidence if validation present
                    _ => adjustedConfidence
                };
            }
            
            return Math.Max(0.1m, Math.Min(1.0m, adjustedConfidence));
        }

        private string GetRecommendation(string cweId)
        {
            return cweId switch
            {
                "CWE-89" => "Use parameterized queries or ORM methods to prevent SQL injection",
                "CWE-79" => "Encode output and use context-appropriate sanitization",
                "CWE-78" => "Avoid dynamic command construction; use safe APIs",
                "CWE-22" => "Validate and sanitize file paths; use safe path operations",
                "CWE-798" => "Store credentials securely using configuration or key management",
                "CWE-502" => "Use safe serialization methods and validate input",
                _ => "Review code for security best practices"
            };
        }
    }

    public class VulnerabilityPattern
    {
        public string Id { get; set; } = string.Empty;
        public string Name { get; set; } = string.Empty;
        public Regex Regex { get; set; } = null!;
        public VulnerabilitySeverity Severity { get; set; }
        public decimal BaseConfidence { get; set; }
        public string Description { get; set; } = string.Empty;
    }

}